library(geosphere)
library(ggmap)
library(mvtnorm)
library(coda)
library(MASS)
library(reshape2)

#set reference points & bearings Nelson's column, London eye and Big ben
landmarks<-data.frame(lon=c(-0.12790934620440858, -0.11964167814801072,
                            -0.1245496367169894),
                      lat=c(51.50779711415662, 51.50345826867559, 
                            51.5008340546969))
alpha <- 19.54
beta <- 106.04
gamma <- 144.43

#produce map of these and their bearings
d <- seq(0, 0.4, 0.0001)
line1 <- data.frame(lon=landmarks[1,1] + d*sin(alpha*pi/180+pi),
                    lat=landmarks[1,2] + d*cos(alpha*pi/180+pi))
line2 <- data.frame(lon=landmarks[2,1] + d*sin(beta*pi/180+pi),
                    lat=landmarks[2,2] + d*cos(beta*pi/180+pi))
line3 <- data.frame(lon=landmarks[3,1] + d*sin(gamma*pi/180+pi),
                    lat=landmarks[3,2] + d*cos(gamma*pi/180+pi))
register_google(key="AIzaSyDG_GUhJvpvO4DeYu5KDSu0EulqQFlla_o",write=TRUE)
map <- get_map(c(-0.1257,51.5045),zoom=16,maptype="roadmap")
bearingsPlot <- ggmap(map)+
  geom_point(aes(x = lon, y = lat), size = 1, data = landmarks, alpha = .5) +
  geom_line(aes(x=lon,y=lat),data=line1) +
  geom_line(aes(x=lon,y=lat),data=line2) +
  geom_line(aes(x=lon,y=lat),data=line3)
bearingsPlot
zoom_map <- get_map(c(-0.128,51.5065),zoom=18,maptype="roadmap")
bearingsPlot <- ggmap(zoom_map)+
  geom_point(aes(x = lon, y = lat), size = 1, data = landmarks, alpha = .5) +
  geom_line(aes(x=lon,y=lat),data=line1) +
  geom_line(aes(x=lon,y=lat),data=line2) +
  geom_line(aes(x=lon,y=lat),data=line3)
bearingsPlot

#define likelihood and prior functions to use in evaluation
#assuming a reasonable wide prior for parameters
bearing_360 <- function(p1, p2) {
  bearing_180 <- bearing(p1, p2)
  if (bearing_180 < 0){
    return(360+bearing_180)
  } else{
    return(bearing_180)
  }
}
loglikelihood <- function (params) {
  point <- params[1:2]
  sigma <- params[3]
  dnorm(alpha, mean=bearing_360(point, landmarks[1,]),sd=sqrt(sigma), log=T) +
    dnorm(beta, mean=bearing_360(point, landmarks[2,]),sd=sqrt(sigma), log=T) +
    dnorm(gamma, mean=bearing_360(point, landmarks[3,]),sd=sqrt(sigma), log=T)
}
logprior <- function (params) {
  theta <- params[1]
  lambda <- params[2]
  sigma <- params[3]
  dunif(theta, -1, 0, log=T) + dunif(lambda, 51, 52, log=T) + 
    dexp(sigma, 20, log=T)
}

#want to find best place to initialise simulation i.e near expected mode
intersectBearings <- function(p1,b1,p2,b2) {
  x1 <- p1[1]
  x2 <- p1[1] + 0.1*sin(b1*pi/180)
  x3 <- p2[1]
  x4 <- p2[1] + 0.1*sin(b2*pi/180)
  y1 <- p1[2]
  y2 <- p1[2] + 0.1*cos(b1*pi/180)
  y3 <- p2[2]
  y4 <- p2[2] + 0.1*cos(b2*pi/180)
  x <- ((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4))
  y <- ((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4))
  return(as.numeric(c(x,y)))
}
intersection <- intersectBearings(landmarks[1,],alpha,landmarks[2,],beta)
bearingsPlot + geom_point(aes(intersection[1], intersection[2], col='red')) +
  theme(legend.position = 'none')

#use this to generate draw with a sensible start
#dimensions are iteration index, parameter, chain
#parameters are ordered lambda, theta, sigma
draws <- array(0,dim=c(10000,3,3))
draws[10000,1,] <- runif(3,intersection[1] - 0.01, intersection[1] + 0.01)
draws[10000,2,] <- runif(3,intersection[2] - 0.01, intersection[2] + 0.01)
draws[10000,3,] <- rexp(3,20)

#evaluate posterior by sampling using M-H algorithm
converged <- FALSE
step <- 2
accepted <- rep(1,3)
while (!all(converged)) {
  draws[1,,] <- draws[10000,,]
  for (chain in 1:3) {
    prop.cov <- c(1e-8,1e-8,1e-3)*diag(3) #beginning with arbitrary proposal
    proposed <- c(0,0,-1)
    while (proposed[3] < 0) {
      proposed <- rmvnorm(1,draws[step-1,,chain],prop.cov)
    }
    r <- loglikelihood(proposed) + 
      logprior(proposed) -
      loglikelihood(draws[step-1,,chain]) - 
      logprior(draws[step-1,,chain])
    a <- min(1,r)
    u <- runif(1)
    if (u < a) {
      draws[step,,chain] <- proposed
      accepted[chain] <- accepted[chain]+1
    } else {
      draws[step,,chain] <- draws[step-1,,chain]
    }
  }
  step <- step + 1
  if (step > 100) {
    chainlist <- mcmc.list(Chain1=mcmc(draws[,,1]),
                           Chain2=mcmc(draws[,,2]),
                           Chain3=mcmc(draws[,,3]))
    converged <- all((gelman.diag(chainlist)$psrf[,2])<1.2)
  }
}

#plot chains visually to confirm convergence

#now convergence is achieved, we begin collecting the final sample
sample <- array(0,dim=c(25000,3,3))
sample[1,,] <- draws[step-1,,]
accepted <- rep(1,3)
for (step in 2:25000) {
  print(step)
  for (chain in 1:3) {
    prop.cov <- c(1e-8,1e-8,1e-4)*diag(3)
    while (proposed[3] < 0) {
      proposed <- rmvnorm(1,draws[step-1,,chain],prop.cov)
    }
    r <- loglikelihood(proposed) + 
      logprior(proposed) -
      loglikelihood(draws[step-1,,chain]) - 
      logprior(draws[step-1,,chain])
    a <- min(1,r)
    u <- runif(1)
    if (u < a) {
      sample[step,,chain] <- proposed
      accepted[chain] <- accepted[chain]+1
    } else {
      sample[step,,chain] <- sample[step-1,,chain]
    }
  }
}

#then need to consider adding the snippet to plot chains as being sampled



#use given code to plot density estimate on bearingsmap


#assume proximity to a road
#and assume non-proximity to a road ?
