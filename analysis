library(ggmap)
library(mvtnorm)
library(geosphere)

#set reference points & bearings Nelson's column, London eye and Big ben
landmarks<-data.frame(lon=c(-0.12790934620440858, -0.11964167814801072,
                            -0.1245496367169894),
                      lat=c(51.50779711415662, 51.50345826867559, 
                            51.5008340546969))
alpha <- 9.54
beta <- 116.04
gamma <- 155.43

#produce map of these and their bearings
d <- seq(0, 0.4, 0.0001)
line1 <- data.frame(lon=landmarks[1,1] + d*sin(alpha*pi/180+pi),
                    lat=landmarks[1,2] + d*cos(alpha*pi/180+pi))
line2 <- data.frame(lon=landmarks[2,1] + d*sin(beta*pi/180+pi),
                    lat=landmarks[2,2] + d*cos(beta*pi/180+pi))
line3 <- data.frame(lon=landmarks[3,1] + d*sin(gamma*pi/180+pi),
                    lat=landmarks[3,2] + d*cos(gamma*pi/180+pi))
register_google(key="AIzaSyDG_GUhJvpvO4DeYu5KDSu0EulqQFlla_o",write=TRUE)
map <- get_map(c(-0.1257,51.5045),zoom=16,maptype="roadmap")
bearingsPlot <- ggmap(map)+
  geom_point(aes(x = lon, y = lat), size = 1, data = landmarks, alpha = .5) +
  geom_line(aes(x=lon,y=lat),data=line1) +
  geom_line(aes(x=lon,y=lat),data=line2) +
  geom_line(aes(x=lon,y=lat),data=line3)
bearingsPlot

#define likelihood and prior functions to use in evaluation
#assuming a reasonable wide prior for parameters
bearing_360 <- function(p1, p2) {
  bearing_180 <- bearing(p1, p2)
  if (bearing_180 < 0){
    return(360+bearing_180)
  } else{
    return(bearing_180)
  }
}
likelihood <- function (params) {
  point <- params[1:2]
  sigma <- params[3]
  dnorm(alpha, mean=bearing_360(point, landmarks[1,]),sd=sqrt(sigma)) *
    dnorm(beta, mean=bearing_360(point, landmarks[2,]),sd=sqrt(sigma)) *
    dnorm(gamma, mean=bearing_360(point, landmarks[3,]),sd=sqrt(sigma))
}
prior <- function (params) {
  theta <- params[1]
  lambda <- params[2]
  sigma <- params[3]
  dunif(theta, -1, 0)*dunif(lambda,51,52)*dexp(sqrt(sigma),20)
}

#want to find best place to initialise simulation i.e near expected mode
intersectBearings <- function(p1,b1,p2,b2) {
  x1 <- p1[1]
  x2 <- p1[1] + 0.1*sin(b1*pi/180)
  x3 <- p2[1]
  x4 <- p2[1] + 0.1*sin(b2*pi/180)
  y1 <- p1[2]
  y2 <- p1[2] + 0.1*cos(b1*pi/180)
  y3 <- p2[2]
  y4 <- p2[2] + 0.1*cos(b2*pi/180)
  x <- ((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4))
  y <- ((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4))
  return(as.numeric(c(x,y)))
}
intersection <- intersectBearings(landmarks[1,],alpha,landmarks[2,],beta)
bearingsPlot + geom_point(aes(intersection[1], intersection[2], col='red'))

#use this to generate draw with a sensible start
#first dimension is the iteration index
#second dimension is the parameter index
#third dimension is the chain index
draws <- array(0,dim=c(4000,3,3))
draws[1,1,] <- runif(3,intersection[1] - 0.01, intersection[1] + 0.01)
draws[1,2,] <- runif(3,intersection[2] - 0.01, intersection[2] + 0.01)
draws[1,3,] <- rexp(3,20)

#evaluate posterior by sampling using M-H algorithm
accepted <- rep(1,3)
for (step in 2:4000) {
  for (chain in 1:3) {
    #beginning with arbitrary proposal
    prop.cov <- c(1e-8,1e-8,1e-4)*diag(3)
    proposed <- rmvnorm(1,draws[step-1,,chain],prop.cov)
    r <- likelihood(proposed)*prior(proposed)/
      (likelihood(draws[step-1,,chain])*prior(draws[step-1,,chain]))
    #loop not running rn because denom here is returning 0
    #don't think it ever should
    #need to figure out what it should be representing
    #and what mistake is causing it to show zero
    a <- min(1,r)
    u <- runif(1)
    if (u < a) {
      draws[step,,chain] <- proposed
      accepted[chain] <- accepted[chain]+1
    } else {
      draws[step,,chain] <- draws[step-1,,chain]
    }
  }
}



#assume proximity to a road
#and assume non-proximity to a road ?
