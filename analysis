library(geosphere)
library(ggmap)
library(mvtnorm)
library(coda)
library(MASS)
library(reshape2)

#set reference points & bearings Nelson's column, London eye and Big ben
landmarks<-data.frame(lon=c(-0.12790934620440858, -0.11964167814801072,
                            -0.1245496367169894),
                      lat=c(51.50779711415662, 51.50345826867559, 
                            51.5008340546969))
alpha <- 19.54
beta <- 106.04
gamma <- 144.43

#produce map of these and their bearings
d <- seq(0, 0.4, 0.0001)
line1 <- data.frame(lon=landmarks[1,1] + d*sin(alpha*pi/180+pi),
                    lat=landmarks[1,2] + d*cos(alpha*pi/180+pi))
line2 <- data.frame(lon=landmarks[2,1] + d*sin(beta*pi/180+pi),
                    lat=landmarks[2,2] + d*cos(beta*pi/180+pi))
line3 <- data.frame(lon=landmarks[3,1] + d*sin(gamma*pi/180+pi),
                    lat=landmarks[3,2] + d*cos(gamma*pi/180+pi))
register_google(key="AIzaSyDG_GUhJvpvO4DeYu5KDSu0EulqQFlla_o",write=TRUE)
map <- get_map(c(-0.1257,51.5045),zoom=16,maptype="roadmap")
bearingsPlot <- ggmap(map)+
  geom_point(aes(x = lon, y = lat), size = 1, data = landmarks, alpha = .5) +
  geom_line(aes(x=lon,y=lat),data=line1) +
  geom_line(aes(x=lon,y=lat),data=line2) +
  geom_line(aes(x=lon,y=lat),data=line3)
bearingsPlot
zoom_map <- get_map(c(-0.128,51.5065),zoom=18,maptype="roadmap")
bearingsPlot <- ggmap(zoom_map)+
  geom_point(aes(x = lon, y = lat), size = 1, data = landmarks, alpha = .5) +
  geom_line(aes(x=lon,y=lat),data=line1) +
  geom_line(aes(x=lon,y=lat),data=line2) +
  geom_line(aes(x=lon,y=lat),data=line3)
bearingsPlot

#define likelihood and prior functions to use in evaluation
#assuming a reasonable wide prior for parameters
bearing_360 <- function(p1, p2) {
  bearing_180 <- bearing(p1, p2)
  if (bearing_180 < 0){
    return(360+bearing_180)
  } else{
    return(bearing_180)
  }
}
loglikelihood <- function (params) {
  point <- params[1:2]
  sigma <- params[3]
  dnorm(alpha, mean=bearing_360(point, landmarks[1,]),sd=sqrt(sigma), log=T) +
    dnorm(beta, mean=bearing_360(point, landmarks[2,]),sd=sqrt(sigma), log=T) +
    dnorm(gamma, mean=bearing_360(point, landmarks[3,]),sd=sqrt(sigma), log=T)
}
logprior <- function (params) {
  theta <- params[1]
  lambda <- params[2]
  sigma <- params[3]
  dunif(theta, -0.5, 0, log=T) + dunif(lambda, 51.25, 51.75, log=T) + 
    dexp(sigma, 20, log=T)
}

#want to find best place to initialise simulation i.e near expected mode
intersectBearings <- function(p1,b1,p2,b2) {
  x1 <- p1[1]
  x2 <- p1[1] + 0.1*sin(b1*pi/180)
  x3 <- p2[1]
  x4 <- p2[1] + 0.1*sin(b2*pi/180)
  y1 <- p1[2]
  y2 <- p1[2] + 0.1*cos(b1*pi/180)
  y3 <- p2[2]
  y4 <- p2[2] + 0.1*cos(b2*pi/180)
  x <- ((x1*y2-y1*x2)*(x3-x4)-(x1-x2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4))
  y <- ((x1*y2-y1*x2)*(y3-y4)-(y1-y2)*(x3*y4-y3*x4))/((x1-x2)*(y3-y4)-(y1-y2)*(x3-x4))
  return(as.numeric(c(x,y)))
}
intersection <- intersectBearings(landmarks[1,],alpha,landmarks[2,],beta)
bearingsPlot + geom_point(aes(intersection[1], intersection[2], colour='green')) +
  theme(legend.position = 'none')

#use this to generate draw with a sensible start
#dimensions are iteration index, parameter, chain
#parameters are ordered lambda, theta, sigma
draws <- array(0,dim=c(10000,3,3))
draws[10000,1,] <- runif(3,intersection[1] - 0.01, intersection[1] + 0.01)
draws[10000,2,] <- runif(3,intersection[2] - 0.01, intersection[2] + 0.01)
draws[10000,3,] <- rexp(3,20)

#evaluate posterior by sampling using M-H algorithm
converged <- c(FALSE, FALSE, FALSE)
step <- 2
accepted <- rep(1,3)
while (!all(converged)) {
  draws[1,,] <- draws[10000,,]
  for (chain in 1:3) {
    prop.cov <- c(1e-8,1e-8,1e-4)*diag(3) #beginning with arbitrary proposal
    proposed <- c(0,0,-1)
    while (proposed[3] < 0) {
      proposed <- rmvnorm(1,draws[step-1,,chain],prop.cov)
    }
    r <- loglikelihood(proposed) + 
      logprior(proposed) -
      loglikelihood(draws[step-1,,chain]) - 
      logprior(draws[step-1,,chain])
    a <- min(1,r)
    u <- runif(1)
    if (u < a) {
      draws[step,,chain] <- proposed
      accepted[chain] <- accepted[chain]+1
    } else {
      draws[step,,chain] <- draws[step-1,,chain]
    }
  }
  step <- step + 1
  if (step > 100) {
    chainlist_lambda <- mcmc.list(Chain1=mcmc(draws[,1,1]),
                                  Chain2=mcmc(draws[,1,2]),
                                  Chain3=mcmc(draws[,1,3]))
    chainlist_theta <- mcmc.list(Chain1=mcmc(draws[,2,1]),
                                 Chain2=mcmc(draws[,2,2]),
                                 Chain3=mcmc(draws[,2,3]))
    chainlist_sigma <- mcmc.list(Chain1=mcmc(draws[,3,1]),
                                 Chain2=mcmc(draws[,3,2]),
                                 Chain3=mcmc(draws[,3,3]))
    converged[1] <- all((gelman.diag(chainlist_lambda)$psrf[,2])<1.2)
    converged[2] <- all((gelman.diag(chainlist_theta)$psrf[,2])<1.2)
    converged[3] <- all((gelman.diag(chainlist_sigma)$psrf[,2])<1.2)
  }
}

#plot these chains visually to confirm convergence
plot(1:(step-1),draws[1:(step-1),1,1],type="l",col=2, ylim=c(-0.14,-0.12))
lines(x=1:(step-1),y=draws[1:(step-1),1,2],col=3)
lines(1:(step-1),draws[1:(step-1),1,3],col=4)
plot(1:(step-1),draws[1:(step-1),2,1],type="l",col=2)
lines(1:(step-1),draws[1:(step-1),2,2],col=3)
lines(1:(step-1),draws[1:(step-1),2,3],col=4)
plot(1:(step-1),draws[1:(step-1),3,1],type="l",col=2)
lines(1:(step-1),draws[1:(step-1),3,2],col=3)
lines(1:(step-1),draws[1:(step-1),3,3],col=4)

#now convergence is achieved, we begin collecting the final sample
sample <- array(0,dim=c(25000,3,3))
sample[1,,] <- draws[step-1,,]
accepted <- rep(1,3)
for (step in 2:25000) {
  for (chain in 1:3) {
    prop.cov <- c(1e-8,1e-8,1e-4)*diag(3)
    proposed <- c(0,0,-1)
    while (proposed[3] < 0) {
      proposed <- rmvnorm(1,sample[step-1,,chain],prop.cov)
    }
    r <- loglikelihood(proposed) + 
      logprior(proposed) -
      loglikelihood(sample[step-1,,chain]) - 
      logprior(sample[step-1,,chain])
    a <- min(1,r)
    u <- runif(1)
    if (u < a) {
      sample[step,,chain] <- proposed
      accepted[chain] <- accepted[chain]+1
    } else {
      sample[step,,chain] <- sample[step-1,,chain]
    }
  }
}
acceptance_rate <- accepted/250
print(acceptance_rate)
#plot chains to check we plotted those with convergence
plot(1:(step-1),sample[1:(step-1),1,1],type="l",col=2)
lines(1:(step-1),sample[1:(step-1),1,2],col=3)
lines(1:(step-1),sample[1:(step-1),1,3],col=4)
plot(1:(step-1),sample[1:(step-1),2,1],type="l",col=2)
lines(1:(step-1),sample[1:(step-1),2,2],col=3)
lines(1:(step-1),sample[1:(step-1),2,3],col=4)
plot(1:(step-1),sample[1:(step-1),3,1],type="l",col=2)
lines(1:(step-1),sample[1:(step-1),3,2],col=3)
lines(1:(step-1),sample[1:(step-1),3,3],col=4)
#plot in a better way?
#have two tabs open describing options, think I want trace plots, 
#are trace plots different to what I've done?

#plotting the lambda and theta coordinate estimates
D <- kde2d(as.vector(sample[,1,]),as.vector(sample[,2,]),
           h=c(sd(sample[,1,]),sd(sample[,2,])),
           n=1024,
           lims=c(-0.1290,-0.130,51.5045,51.5060)) # Enough to cover map
z <- melt(D$z)
z$Var1<-D$x[z$Var1]
z$Var2<-D$y[z$Var2]
map <- get_map(c(mean(sample[,1,]),mean(sample[,2,])),zoom=18,maptype="road")
mapPoints <- ggmap(map)+
  geom_point(aes(x = lon, y = lat), size = 1, data = landmarks, alpha = .5) +
  geom_raster(data=z,aes(x=Var1,y=Var2,fill=value))+
  guides(fill=FALSE,alpha=FALSE)+
  scale_fill_gradientn(colours=c("#0000FF00","#0000FFFF"))+
  coord_cartesian() +
  geom_line(aes(x=lon,y=lat),data=line1) +
  geom_line(aes(x=lon,y=lat),data=line2) +
  geom_line(aes(x=lon,y=lat),data=line3)+
  geom_point(aes(x=lon,y=lat),
             data=data.frame(lon=mean(sample[,1,]),lat=mean(sample[,2,])),
             size=0.5,colour="#FF0000")
mapPoints
#mean point estimate is red dot


#assume proximity to a road
#and assume non-proximity to a road ?
